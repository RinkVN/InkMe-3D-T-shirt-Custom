/* __V3D_TEMPLATE__ - template-based file; delete this line to prevent this file from being updated */

'use strict';

window.addEventListener('load', e => {
  const params = v3d.AppUtils.getPageParams();
  createApp({
    containerId: 'v3d-container',
    fsButtonId: 'fullscreen-button',
    sceneURL: params.load || 'tshirt-sizingtest.gltf',
    logicURL: params.logic || 'visual_logic.js',
  });
});

/*
//---------------variables used for canvas recording---------------//

let mediaRecorder;
let recordedBlobs = [];
let sourceBuffer;
const mediaSource = new MediaSource();
mediaSource.addEventListener('sourceopen', handleSourceOpen, false);

//----------------end here-----------------------------------------//
*/

async function createApp({ containerId, fsButtonId = null, sceneURL, logicURL = '' }) {
  if (!sceneURL) {
    console.log('No scene URL specified');
    return;
  }

  // some puzzles can benefit from cache
  v3d.Cache.enabled = true;

  let PL = null, PE = null;
  if (v3d.AppUtils.isXML(logicURL)) {
    const PUZZLES_DIR = '/puzzles/';
    const logicURLJS = logicURL.match(/(.*)\.xml$/)[1] + '.js';
    PL = await new v3d.PuzzlesLoader().loadEditorWithLogic(PUZZLES_DIR, logicURLJS);
    PE = v3d.PE;
  } else if (v3d.AppUtils.isJS(logicURL)) {
    PL = await new v3d.PuzzlesLoader().loadLogic(logicURL);
  }

  let initOptions = { useFullscreen: true };
  if (PL) {
    initOptions = PL.execInitPuzzles({ container: containerId }).initOptions;
  }
  sceneURL = initOptions.useCompAssets ? `${sceneURL}.xz` : sceneURL;

  const disposeFullscreen = prepareFullscreen(containerId, fsButtonId,
    initOptions.useFullscreen);
  const preloader = createPreloader(containerId, initOptions, PE);

  const app = createAppInstance(containerId, initOptions, preloader, PE);
  app.addEventListener('dispose', () => disposeFullscreen && disposeFullscreen());

  if (initOptions.preloaderStartCb) initOptions.preloaderStartCb();
  app.loadScene(sceneURL, () => {
    app.enableControls();
    app.run();

    if (PE) PE.updateAppInstance(app);
    if (PL) PL.init(app, initOptions);

    runCode(app, PL);
  }, null, () => {
    console.log(`Can't load the scene ${sceneURL}`);
  });

  return { app, PL };
}


function createPreloader(containerId, initOptions, PE) {
  const preloader = initOptions.useCustomPreloader
    ? createCustomPreloader(initOptions.preloaderProgressCb,
      initOptions.preloaderEndCb)
    : new v3d.SimplePreloader({ container: containerId });

  if (PE) puzzlesEditorPreparePreloader(preloader, PE);

  return preloader;
}

function createCustomPreloader(updateCb, finishCb) {
  function CustomPreloader() {
    v3d.Preloader.call(this);
  }

  CustomPreloader.prototype = Object.assign(Object.create(v3d.Preloader.prototype), {
    onUpdate: function (percentage) {
      v3d.Preloader.prototype.onUpdate.call(this, percentage);
      if (updateCb) updateCb(percentage);
    },
    onFinish: function () {
      v3d.Preloader.prototype.onFinish.call(this);
      if (finishCb) finishCb();
    }
  });

  return new CustomPreloader();
}

/**
 * Modify the app's preloader to track the loading process in the Puzzles Editor.
 */
function puzzlesEditorPreparePreloader(preloader, PE) {
  const _onUpdate = preloader.onUpdate.bind(preloader);
  preloader.onUpdate = function (percentage) {
    _onUpdate(percentage);
    PE.loadingUpdateCb(percentage);
  }

  const _onFinish = preloader.onFinish.bind(preloader);
  preloader.onFinish = function () {
    _onFinish();
    PE.loadingFinishCb();
  }
}


function createAppInstance(containerId, initOptions, preloader, PE) {
  const ctxSettings = {};
  if (initOptions.useBkgTransp) ctxSettings.alpha = true;
  if (initOptions.preserveDrawBuf) ctxSettings.preserveDrawingBuffer = true;

  const app = new v3d.App(containerId, ctxSettings, preloader);
  if (initOptions.useBkgTransp) {
    app.clearBkgOnLoad = true;
    if (app.renderer) {
      app.renderer.setClearColor(0x000000, 0);
    }
  }

  // namespace for communicating with code generated by Puzzles
  app.ExternalInterface = {};
  prepareExternalInterface(app);
  if (PE) PE.viewportUseAppInstance(app);

  return app;
}


function prepareFullscreen(containerId, fsButtonId, useFullscreen) {
  const container = document.getElementById(containerId);
  const fsButton = document.getElementById(fsButtonId);

  if (!fsButton) {
    return null;
  }
  if (!useFullscreen) {
    if (fsButton) fsButton.style.display = 'none';
    return null;
  }

  const fsEnabled = () => document.fullscreenEnabled
    || document.webkitFullscreenEnabled
    || document.mozFullScreenEnabled
    || document.msFullscreenEnabled;
  const fsElement = () => document.fullscreenElement
    || document.webkitFullscreenElement
    || document.mozFullScreenElement
    || document.msFullscreenElement;
  const requestFs = elem => (elem.requestFullscreen
    || elem.mozRequestFullScreen
    || elem.webkitRequestFullscreen
    || elem.msRequestFullscreen).call(elem);
  const exitFs = () => (document.exitFullscreen
    || document.mozCancelFullScreen
    || document.webkitExitFullscreen
    || document.msExitFullscreen).call(document);
  const changeFs = () => {
    const elem = fsElement();
    fsButton.classList.add(elem ? 'fullscreen-close' : 'fullscreen-open');
    fsButton.classList.remove(elem ? 'fullscreen-open' : 'fullscreen-close');
  };

  function fsButtonClick(event) {
    event.stopPropagation();
    if (fsElement()) {
      exitFs();
    } else {
      requestFs(container);
    }
  }

  if (fsEnabled()) fsButton.style.display = 'inline';

  fsButton.addEventListener('click', fsButtonClick);
  document.addEventListener('webkitfullscreenchange', changeFs);
  document.addEventListener('mozfullscreenchange', changeFs);
  document.addEventListener('msfullscreenchange', changeFs);
  document.addEventListener('fullscreenchange', changeFs);

  const disposeFullscreen = () => {
    fsButton.removeEventListener('click', fsButtonClick);
    document.removeEventListener('webkitfullscreenchange', changeFs);
    document.removeEventListener('mozfullscreenchange', changeFs);
    document.removeEventListener('msfullscreenchange', changeFs);
    document.removeEventListener('fullscreenchange', changeFs);
  }

  return disposeFullscreen;
}

// Remove BG Logic
document.addEventListener("DOMContentLoaded", function () {
  const REMOVE_BG_API_KEY = "rQFhfUyWaG1qBo1CffWLk6bn";
  const container = document.querySelector(".remove-bg-container");
  const input = container.querySelector(".remove-bg-input");
  const processBtn = container.querySelector(".remove-bg-process");
  const preview = container.querySelector(".remove-bg-preview");
  const loading = container.querySelector(".remove-bg-loading");
  const downloadBtn = container.querySelector(
    ".remove-bg-add-to-canvas"
  );
  const originalImg = preview.querySelector(".preview-original img");
  const resultImg = preview.querySelector(".preview-result img");

  let processedImageBlob = null;

  input.addEventListener("change", function (e) {
    const file = e.target.files[0];
    if (!file) return;

    if (file.size > 10 * 1024 * 1024) {
      alert("File size must be less than 10MB");
      return;
    }

    // Reset interface
    downloadBtn.style.display = "none";
    processedImageBlob = null;

    // Show original image preview
    const reader = new FileReader();
    reader.onload = function (e) {
      originalImg.src = e.target.result;
      preview.style.display = "flex";
      processBtn.style.display = "block";
      resultImg.src = "";
    };
    reader.readAsDataURL(file);
  });

  processBtn.addEventListener("click", async function () {
    const file = input.files[0];
    if (!file) return;

    loading.style.display = "flex";
    processBtn.style.display = "none";
    preview.style.display = "none";
    downloadBtn.style.display = "none";

    try {
      const formData = new FormData();
      formData.append("image_file", file);

      const response = await fetch(
        "https://api.remove.bg/v1.0/removebg",
        {
          method: "POST",
          headers: {
            "X-Api-Key": REMOVE_BG_API_KEY,
          },
          body: formData,
        }
      );

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      processedImageBlob = await response.blob();
      const imageUrl = URL.createObjectURL(processedImageBlob);

      resultImg.onload = function () {
        URL.revokeObjectURL(imageUrl);
      };
      resultImg.src = imageUrl;

      preview.style.display = "flex";
      if (processedImageBlob) {
        downloadBtn.style.display = "flex";
      }
    } catch (error) {
      console.error("Error removing background:", error);
      alert("Error removing background. Please try again.");
      processBtn.style.display = "block";
      downloadBtn.style.display = "none";
    } finally {
      loading.style.display = "none";
    }
  });

  downloadBtn.addEventListener("click", function () {
    if (!processedImageBlob) return;

    // Create a download link
    const url = URL.createObjectURL(processedImageBlob);
    const a = document.createElement("a");
    a.href = url;

    // Get the original filename and add -nobg suffix
    const originalName = input.files[0].name;
    const nameWithoutExt = originalName.substring(
      0,
      originalName.lastIndexOf(".")
    );
    const extension = originalName.substring(
      originalName.lastIndexOf(".")
    );
    a.download = `${nameWithoutExt}-nobg${extension}`;

    // Trigger download
    document.body.appendChild(a);
    a.click();

    // Cleanup
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    // Reset the interface
    input.value = "";
    preview.style.display = "none";
    processBtn.style.display = "none";
    downloadBtn.style.display = "none";
    originalImg.src = "";
    resultImg.src = "";
    processedImageBlob = null;
  });

  // Popup logic
  const openBtn = document.getElementById("open-remove-bg");
  const popup = document.getElementById("remove-bg-popup");
  const closeBtn = document.getElementById("close-remove-bg");
  openBtn.addEventListener("click", function () {
    popup.style.display = "flex";
  });
  closeBtn.addEventListener("click", function () {
    popup.style.display = "none";
  });
});


document.addEventListener('DOMContentLoaded', function () {
  var closeRemoveBgBtn = document.getElementById('close-remove-bg');
  if (closeRemoveBgBtn) {
    closeRemoveBgBtn.onclick = function () {
      document.getElementById('remove-bg-popup').style.display = 'none';
    };
  }
});


// Content Moderation API - Gọi qua server để bảo mật API key
async function checkInappropriateContent(base64ImageData) {
  try {
    // Gọi API endpoint của server thay vì gọi trực tiếp OpenAI
    const response = await fetch('/api/ai/moderate-content', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        imageData: base64ImageData
      })
    });

    if (!response.ok) {
      console.error('Server API request failed:', response.statusText);
      // Trả về "an toàn" để không chặn người dùng khi API có lỗi
      return {
        isInappropriate: false,
        reason: `API Error: ${response.statusText}`
      };
    }

    const result = await response.json();

    return {
      isInappropriate: result.isInappropriate,
      reason: result.reason
    };

  } catch (error) {
    console.error('Lỗi khi kiểm tra nội dung:', error);
    // Trả về "an toàn" để không chặn người dùng nếu có lỗi
    return {
      isInappropriate: false,
      reason: "An error occurred during check."
    };
  }
}

// Cart button loading functionality
document.addEventListener('DOMContentLoaded', function () {
  const cartButton = document.getElementById('cart_button');
  const cartLoadingOverlay = document.getElementById('cartLoadingOverlay');

  if (cartButton && cartLoadingOverlay) {
    cartButton.addEventListener('click', function () {
      // Add loading state to button
      cartButton.classList.add('loading');

      // Show loading overlay
      cartLoadingOverlay.classList.add('show');

      // Remove loading state after 3 seconds
      setTimeout(function () {
        cartButton.classList.remove('loading');
        cartLoadingOverlay.classList.remove('show');
      }, 3000);
    });
  }
});


function prepareExternalInterface(app) {
  /**
   * Register functions in the app.ExternalInterface to call them from
   * Puzzles, e.g:
   * app.ExternalInterface.myJSFunction = function() {
   *     console.log('Hello, World!');
   * }
   */
}

function runCode(app, puzzles) {

  //----------------function used for recording--------------//


  //--------------------end here---------------------//
}

function startRecording() { } // get rit of calling this function

function stopRecording() { } // get rit of calling this function

function handleStop(event) { } // get rit of calling this function

function handleDataAvailable(event) { } // get rit of calling this function

function handleSourceOpen(event) { } // get rit of calling this function