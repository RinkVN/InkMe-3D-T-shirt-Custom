/* __V3D_TEMPLATE__ - template-based file; delete this line to prevent this file from being updated */

'use strict';

window.addEventListener('load', e => {
    const params = v3d.AppUtils.getPageParams();
    createApp({
        containerId: 'v3d-container',
        fsButtonId: 'fullscreen-button',
        sceneURL: params.load || 'tshirt-sizingtest.gltf',
        logicURL: params.logic || 'visual_logic.js',
    });
});

/*
//---------------variables used for canvas recording---------------//

let mediaRecorder;
let recordedBlobs = [];
let sourceBuffer;
const mediaSource = new MediaSource();
mediaSource.addEventListener('sourceopen', handleSourceOpen, false);

//----------------end here-----------------------------------------//
*/

async function createApp({ containerId, fsButtonId = null, sceneURL, logicURL = '' }) {
    if (!sceneURL) {
        console.log('No scene URL specified');
        return;
    }

    // some puzzles can benefit from cache
    v3d.Cache.enabled = true;

    let PL = null, PE = null;
    if (v3d.AppUtils.isXML(logicURL)) {
        const PUZZLES_DIR = '/puzzles/';
        const logicURLJS = logicURL.match(/(.*)\.xml$/)[1] + '.js';
        PL = await new v3d.PuzzlesLoader().loadEditorWithLogic(PUZZLES_DIR, logicURLJS);
        PE = v3d.PE;
    } else if (v3d.AppUtils.isJS(logicURL)) {
        PL = await new v3d.PuzzlesLoader().loadLogic(logicURL);
    }

    let initOptions = { useFullscreen: true };
    if (PL) {
        initOptions = PL.execInitPuzzles({ container: containerId }).initOptions;
    }
    sceneURL = initOptions.useCompAssets ? `${sceneURL}.xz` : sceneURL;

    const disposeFullscreen = prepareFullscreen(containerId, fsButtonId,
        initOptions.useFullscreen);
    const preloader = createPreloader(containerId, initOptions, PE);

    const app = createAppInstance(containerId, initOptions, preloader, PE);
    app.addEventListener('dispose', () => disposeFullscreen && disposeFullscreen());

    if (initOptions.preloaderStartCb) initOptions.preloaderStartCb();
    app.loadScene(sceneURL, () => {
        app.enableControls();
        app.run();

        if (PE) PE.updateAppInstance(app);
        if (PL) PL.init(app, initOptions);

        runCode(app, PL);
    }, null, () => {
        console.log(`Can't load the scene ${sceneURL}`);
    });

    return { app, PL };
}


function createPreloader(containerId, initOptions, PE) {
    const preloader = initOptions.useCustomPreloader
        ? createCustomPreloader(initOptions.preloaderProgressCb,
            initOptions.preloaderEndCb)
        : new v3d.SimplePreloader({ container: containerId });

    if (PE) puzzlesEditorPreparePreloader(preloader, PE);

    return preloader;
}

function createCustomPreloader(updateCb, finishCb) {
    function CustomPreloader() {
        v3d.Preloader.call(this);
    }

    CustomPreloader.prototype = Object.assign(Object.create(v3d.Preloader.prototype), {
        onUpdate: function (percentage) {
            v3d.Preloader.prototype.onUpdate.call(this, percentage);
            if (updateCb) updateCb(percentage);
        },
        onFinish: function () {
            v3d.Preloader.prototype.onFinish.call(this);
            if (finishCb) finishCb();
        }
    });

    return new CustomPreloader();
}

/**
 * Modify the app's preloader to track the loading process in the Puzzles Editor.
 */
function puzzlesEditorPreparePreloader(preloader, PE) {
    const _onUpdate = preloader.onUpdate.bind(preloader);
    preloader.onUpdate = function (percentage) {
        _onUpdate(percentage);
        PE.loadingUpdateCb(percentage);
    }

    const _onFinish = preloader.onFinish.bind(preloader);
    preloader.onFinish = function () {
        _onFinish();
        PE.loadingFinishCb();
    }
}


function createAppInstance(containerId, initOptions, preloader, PE) {
    const ctxSettings = {};
    if (initOptions.useBkgTransp) ctxSettings.alpha = true;
    if (initOptions.preserveDrawBuf) ctxSettings.preserveDrawingBuffer = true;

    const app = new v3d.App(containerId, ctxSettings, preloader);
    if (initOptions.useBkgTransp) {
        app.clearBkgOnLoad = true;
        if (app.renderer) {
            app.renderer.setClearColor(0x000000, 0);
        }
    }

    // namespace for communicating with code generated by Puzzles
    app.ExternalInterface = {};
    prepareExternalInterface(app);
    if (PE) PE.viewportUseAppInstance(app);

    return app;
}


function prepareFullscreen(containerId, fsButtonId, useFullscreen) {
    const container = document.getElementById(containerId);
    const fsButton = document.getElementById(fsButtonId);

    if (!fsButton) {
        return null;
    }
    if (!useFullscreen) {
        if (fsButton) fsButton.style.display = 'none';
        return null;
    }

    const fsEnabled = () => document.fullscreenEnabled
        || document.webkitFullscreenEnabled
        || document.mozFullScreenEnabled
        || document.msFullscreenEnabled;
    const fsElement = () => document.fullscreenElement
        || document.webkitFullscreenElement
        || document.mozFullScreenElement
        || document.msFullscreenElement;
    const requestFs = elem => (elem.requestFullscreen
        || elem.mozRequestFullScreen
        || elem.webkitRequestFullscreen
        || elem.msRequestFullscreen).call(elem);
    const exitFs = () => (document.exitFullscreen
        || document.mozCancelFullScreen
        || document.webkitExitFullscreen
        || document.msExitFullscreen).call(document);
    const changeFs = () => {
        const elem = fsElement();
        fsButton.classList.add(elem ? 'fullscreen-close' : 'fullscreen-open');
        fsButton.classList.remove(elem ? 'fullscreen-open' : 'fullscreen-close');
    };

    function fsButtonClick(event) {
        event.stopPropagation();
        if (fsElement()) {
            exitFs();
        } else {
            requestFs(container);
        }
    }

    if (fsEnabled()) fsButton.style.display = 'inline';

    fsButton.addEventListener('click', fsButtonClick);
    document.addEventListener('webkitfullscreenchange', changeFs);
    document.addEventListener('mozfullscreenchange', changeFs);
    document.addEventListener('msfullscreenchange', changeFs);
    document.addEventListener('fullscreenchange', changeFs);

    const disposeFullscreen = () => {
        fsButton.removeEventListener('click', fsButtonClick);
        document.removeEventListener('webkitfullscreenchange', changeFs);
        document.removeEventListener('mozfullscreenchange', changeFs);
        document.removeEventListener('msfullscreenchange', changeFs);
        document.removeEventListener('fullscreenchange', changeFs);
    }

    return disposeFullscreen;
}

// Remove BG Logic
document.addEventListener("DOMContentLoaded", function () {
  const REMOVE_BG_API_KEY = "rQFhfUyWaG1qBo1CffWLk6bn";
  const container = document.querySelector(".remove-bg-container");
  const input = container.querySelector(".remove-bg-input");
  const processBtn = container.querySelector(".remove-bg-process");
  const preview = container.querySelector(".remove-bg-preview");
  const loading = container.querySelector(".remove-bg-loading");
  const downloadBtn = container.querySelector(
    ".remove-bg-add-to-canvas"
  );
  const originalImg = preview.querySelector(".preview-original img");
  const resultImg = preview.querySelector(".preview-result img");

  let processedImageBlob = null;

  input.addEventListener("change", function (e) {
    const file = e.target.files[0];
    if (!file) return;

    if (file.size > 10 * 1024 * 1024) {
      alert("File size must be less than 10MB");
      return;
    }

    // Reset interface
    downloadBtn.style.display = "none";
    processedImageBlob = null;

    // Show original image preview
    const reader = new FileReader();
    reader.onload = function (e) {
      originalImg.src = e.target.result;
      preview.style.display = "flex";
      processBtn.style.display = "block";
      resultImg.src = "";
    };
    reader.readAsDataURL(file);
  });

  processBtn.addEventListener("click", async function () {
    const file = input.files[0];
    if (!file) return;

    loading.style.display = "flex";
    processBtn.style.display = "none";
    preview.style.display = "none";
    downloadBtn.style.display = "none";

    try {
      const formData = new FormData();
      formData.append("image_file", file);

      const response = await fetch(
        "https://api.remove.bg/v1.0/removebg",
        {
          method: "POST",
          headers: {
            "X-Api-Key": REMOVE_BG_API_KEY,
          },
          body: formData,
        }
      );

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      processedImageBlob = await response.blob();
      const imageUrl = URL.createObjectURL(processedImageBlob);

      resultImg.onload = function () {
        URL.revokeObjectURL(imageUrl);
      };
      resultImg.src = imageUrl;

      preview.style.display = "flex";
      if (processedImageBlob) {
        downloadBtn.style.display = "flex";
      }
    } catch (error) {
      console.error("Error removing background:", error);
      alert("Error removing background. Please try again.");
      processBtn.style.display = "block";
      downloadBtn.style.display = "none";
    } finally {
      loading.style.display = "none";
    }
  });

  downloadBtn.addEventListener("click", function () {
    if (!processedImageBlob) return;

    // Create a download link
    const url = URL.createObjectURL(processedImageBlob);
    const a = document.createElement("a");
    a.href = url;

    // Get the original filename and add -nobg suffix
    const originalName = input.files[0].name;
    const nameWithoutExt = originalName.substring(
      0,
      originalName.lastIndexOf(".")
    );
    const extension = originalName.substring(
      originalName.lastIndexOf(".")
    );
    a.download = `${nameWithoutExt}-nobg${extension}`;

    // Trigger download
    document.body.appendChild(a);
    a.click();

    // Cleanup
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    // Reset the interface
    input.value = "";
    preview.style.display = "none";
    processBtn.style.display = "none";
    downloadBtn.style.display = "none";
    originalImg.src = "";
    resultImg.src = "";
    processedImageBlob = null;
  });

  // Popup logic
  const openBtn = document.getElementById("open-remove-bg");
  const popup = document.getElementById("remove-bg-popup");
  const closeBtn = document.getElementById("close-remove-bg");
  openBtn.addEventListener("click", function () {
    popup.style.display = "flex";
  });
  closeBtn.addEventListener("click", function () {
    popup.style.display = "none";
  });
});


document.addEventListener('DOMContentLoaded', function () {
  var closeRemoveBgBtn = document.getElementById('close-remove-bg');
  if (closeRemoveBgBtn) {
    closeRemoveBgBtn.onclick = function () {
      document.getElementById('remove-bg-popup').style.display = 'none';
    };
  }
});


// OpenAI Content Moderation API
// Hàm kiểm tra nội dung không phù hợp bằng OpenAI GPT-4 Vision
async function checkInappropriateContent(base64ImageData) {
  // QUAN TRỌNG: Thay thế 'YOUR_OPENAI_API_KEY' bằng API key của bạn
  const OPENAI_API_KEY = '';
  if (!OPENAI_API_KEY || OPENAI_API_KEY === 'YOUR_OPENAI_API_KEY') {
    console.warn("OpenAI API key chưa được cấu hình. Bỏ qua bước kiểm duyệt nội dung.");
    // Trả về kết quả an toàn nếu không có API key để không chặn người dùng
    return {
      isInappropriate: false,
      reason: "API key not configured."
    };
  }

  const payload = {
    "model": "gpt-4o",
    "messages": [{
      "role": "user",
      "content": [{
        "type": "text",
        "text": "Analyze the following image for inappropriate content. Check for graphic violence, gore, blood, hateful symbols, nudity, or sexually explicit material. Respond with a single JSON object with two keys: 'isInappropriate' (boolean) and 'reason' (a string, providing a brief explanation in Vietnamese if inappropriate, or 'an toàn' if not). Do not include any text outside of the JSON object."
      }, {
        "type": "image_url",
        "image_url": {
          "url": base64ImageData,
          "detail": "low" // Dùng "low" để phân tích nhanh và rẻ hơn
        }
      }]
    }],
    "max_tokens": 300
  };

  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${OPENAI_API_KEY}`
      },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error('OpenAI API request failed:', errorData);
      // Trả về "an toàn" để không chặn người dùng khi API có lỗi
      return {
        isInappropriate: false,
        reason: `API Error: ${response.statusText}`
      };
    }

    const result = await response.json();
    const content = result.choices[0].message.content;

    // Dọn dẹp response để chỉ lấy phần JSON
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      console.error("Invalid response from OpenAI, couldn't find JSON:", content);
      return {
        isInappropriate: false,
        reason: "Invalid response from AI."
      };
    }

    const parsedContent = JSON.parse(jsonMatch[0]);

    return {
      isInappropriate: parsedContent.isInappropriate,
      reason: parsedContent.reason
    };

  } catch (error) {
    console.error('Lỗi khi kiểm tra nội dung với OpenAI:', error);
    // Trả về "an toàn" để không chặn người dùng nếu có lỗi
    return {
      isInappropriate: false,
      reason: "An error occurred during check."
    };
  }
}


function prepareExternalInterface(app) {
    /**
     * Register functions in the app.ExternalInterface to call them from
     * Puzzles, e.g:
     * app.ExternalInterface.myJSFunction = function() {
     *     console.log('Hello, World!');
     * }
     */
}

function runCode(app, puzzles) {

    //----------------function used for recording--------------//


    //--------------------end here---------------------//
}

function startRecording() { } // get rit of calling this function

function stopRecording() { } // get rit of calling this function

function handleStop(event) { } // get rit of calling this function

function handleDataAvailable(event) { } // get rit of calling this function

function handleSourceOpen(event) { } // get rit of calling this function